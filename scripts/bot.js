// Generated by CoffeeScript 1.9.3
(function() {

  var BOT_ID = 1201577778;

  // Configure instance. Only projectId and writeKey are required to send data.
  var keenIO = require('keen.io');
  var keen = keenIO.configure({
      projectId: "54ee0af2672e6c11f4d128e8", //process.env['KEEN_PROJECT_ID'],
      writeKey: "7bd5a8b49747b99bac755544aefc9ed0dbd14b2abe51253fa6d1012c42872c58f602e025615daa2dd2c4c0cd4dc01cd6cecd82856751fc4103817bdffa884e3c097bcfe7dba0390af0fb86060ff49574f8e06748c86a5efb3b9d6b98f3643597a322d43bf4dfce3680997b86dc8545a3" //process.env['KEEN_WRITE_KEY']
  });

  // Configue Parse
  var Parse = require('parse').Parse;
  Parse.initialize("74qfiTL7ri6y46c1BO1tMdrMGw04eGLR7DfeJWxB", "rNg0E8Mg3uzPP95sHYaLBfMZ8TAknFs8ySCkw9dT");
  var parseMessage = Parse.Object.extend("Message");

  function updateTeam(res){

    var teamData = {
      name: res.rawMessage.team,
      teamId: res.rawMessage.team
    };

    var team = Parse.Object.extend("Team");
    team.save(teamData, {
      success: function(teamData) {

        robot.log("Parse Message saved correctly");
      },
      error: function(error){
        robot.log(error);
      }
    });
  };

  function updateChannels(res){

    var channelsData = {
      name: res.rawMessage.channel,
      teamId: res.rawMessage.team,
      channelId: res.rawMessage.channel
    };

    var Channel = Parse.Object.extend("Channel");

    var query = new Parse.Query(Channel);
    query.equalTo("channelId")



    channel.save(channelsData, {
      success: function(channelsData) {

        robot.log("Parse Message saved correctly");
      },
      error: function(error){
        robot.log(error);
      }
    });
  };


  module.exports = function(robot) {

    setInterval(function() {

// TODO Save team and channels info in Parse.
      robot.http("https://slack.com/api/channels.list?token=" + process.env['HUBOT_SLACK_TOKEN'])
        .header('Accept', 'application/json')
        .get()(function(err, res, body) {

          var data = JSON.parse(body);



          if (err) {
            robot.log("Encountered an error :( " + err);
          }
      });


    },
    10 * 60 * 1000);

    robot.hear(/(.*)/i, function(res) {

      robot.log("GETTING GENERAL MESSAGE");

      var slackUser = res.message.user;
      var slack = res.message.rawMessage;

      var user = robot.brain.get(slackUser.id);
      if (!user) user = slackUser;

      robot.log("User: " + user.name + " is talking to me.");

      // Save all user message to a variable
      var text = res.match[0];
      robot.log("heard: " + text);

      var message = { from: user.name,
                  channelId: slack.user,
                  teamId: slack.team,
                  text: text
                };

      keen.addEvent("message", message, function(err, keenResponse) {
          if (err) {
              robot.log(err);
          } else {
              robot.log("Keen worked!");
          }
      });

      parseMessage.save(message, {
        success: function(parseMessage) {

          robot.log("Parse Message saved correctly");
        },
        error: function(error){
          robot.log(error);
        }
      });

      return;
    });

    robot.router.post('/subot/:channel', function(req, res) {
      var data, channel, message;
      channel = req.params.channel;
      data = JSON.parse(req.body.payload);
      message = data.message;

      // Send message to respective channel
      robot.messageRoom(channel, message);
      return res.send('OK');
    });

    robot.error(function(err, res) {
      robot.logger.error("DOES NOT COMPUTE");
      if (res != null) {
        return res.reply("DOES NOT COMPUTE");
      }
    });

    robot.hear(/status/i, function(res) {

      var slackUser = res.message.user;
      var user = robot.brain.get(slackUser.id);

      return res.send('Hi ' + user.name + '. The current status is: ' + user.state);
    });

  //   var annoyIntervalId, answer, enterReplies, leaveReplies, lulz;
  //
  //
    // robot.hear(/badger/i, function(res) {
    //   return res.send("Badgers? BADGERS? WE DON'T NEED NO STINKIN BADGERS");
    // });
  //
  //   robot.respond(/open the (.*) doors/i, function(res) {
  //     var doorType;
  //     doorType = res.match[1];
  //     if (doorType === "pod bay") {
  //       return res.reply("I'm afraid I can't let you do that.");
  //     } else {
  //       return res.reply("Opening " + doorType + " doors");
  //     }
  //   });
  //
  //
  //   robot.hear(/I like pie/i, function(res) {
  //     return res.emote("makes a freshly baked pie");
  //   });
  //   lulz = ['lol', 'rofl', 'lmao'];
  //   robot.respond(/lulz/i, function(res) {
  //     return res.send(res.random(lulz));
  //   });
  //   robot.topic(function(res) {
  //     return res.send(res.message.text + "? That's a Paddlin'");
  //   });
  //   enterReplies = ['Hi', 'Target Acquired', 'Firing', 'Hello friend.', 'Gotcha', 'I see you'];
  //   leaveReplies = ['Are you still there?', 'Target lost', 'Searching'];
  //   robot.enter(function(res) {
  //     return res.send(res.random(enterReplies));
  //   });
  //   robot.leave(function(res) {
  //     return res.send(res.random(leaveReplies));
  //   });
  //   answer = process.env.HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING;
  //   robot.respond(/what is the answer to the ultimate question of life/, function(res) {
  //     if (answer == null) {
  //       res.send("Missing HUBOT_ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE_THE_UNIVERSE_AND_EVERYTHING in environment: please set and try again");
  //       return;
  //     }
  //     return res.send(answer + ", but what is the question?");
  //   });
  //   robot.respond(/you are a little slow/, function(res) {
  //     return setTimeout(function() {
  //       return res.send("Who you calling 'slow'?");
  //     }, 60 * 1000);
  //   });
  //   annoyIntervalId = null;
  //   robot.respond(/annoy me/, function(res) {
  //     if (annoyIntervalId) {
  //       res.send("AAAAAAAAAAAEEEEEEEEEEEEEEEEEEEEEEEEIIIIIIIIHHHHHHHHHH");
  //       return;
  //     }
  //     res.send("Hey, want to hear the most annoying sound in the world?");
  //     return annoyIntervalId = setInterval(function() {
  //       return res.send("AAAAAAAAAAAEEEEEEEEEEEEEEEEEEEEEEEEIIIIIIIIHHHHHHHHHH");
  //     }, 1000);
  //   });
  //   robot.respond(/unannoy me/, function(res) {
  //     if (annoyIntervalId) {
  //       res.send("GUYS, GUYS, GUYS!");
  //       clearInterval(annoyIntervalId);
  //       return annoyIntervalId = null;
  //     } else {
  //       return res.send("Not annoying you right now, am I?");
  //     }
  //   });
  //   robot.router.post('/hubot/chatsecrets/:room', function(req, res) {
  //     var data, room, secret;
  //     room = req.params.room;
  //     data = JSON.parse(req.body.payload);
  //     secret = data.secret;
  //     robot.messageRoom(room, "I have a secret: " + secret);
  //     return res.send('OK');
  //   });
  //   robot.error(function(err, res) {
  //     robot.logger.error("DOES NOT COMPUTE");
  //     if (res != null) {
  //       return res.reply("DOES NOT COMPUTE");
  //     }
  //   });
  //   robot.respond(/have a soda/i, function(res) {
  //     var sodasHad;
  //     sodasHad = robot.brain.get('totalSodas') * 1 || 0;
  //     if (sodasHad > 4) {
  //       return res.reply("I'm too fizzy..");
  //     } else {
  //       res.reply('Sure!');
  //       return robot.brain.set('totalSodas', sodasHad + 1);
  //     }
  //   });
  //   return robot.respond(/sleep it off/i, function(res) {
  //     robot.brain.set('totalSodas', 0);
  //     return res.reply('zzzzz');
  //   });


  };

}).call(this);
